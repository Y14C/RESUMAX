"""
LaTeX Preprocessor for Resumax Application

This module handles preprocessing of AI-generated LaTeX code to fix common issues
before compilation to PDF.

PARAMETERS RECEIVED FROM main.py:
    - latex_code: str - Raw LaTeX code generated by AI model

RETURNS TO main.py:
    - cleaned_latex: str - Preprocessed LaTeX code ready for compilation

PURPOSE:
    - Fixes common LaTeX issues in AI-generated code
    - Ensures proper package imports and structure
    - Handles special characters and symbols
    - Validates LaTeX syntax
    - Removes markdown code blocks if present
    - Fixes placeholder issues

ERROR HANDLING:
    - All preprocessing errors are raised as exceptions
    - No fallback logic provided - errors propagate to main.py for handling
"""

import re
from typing import Dict, List, Optional


def preprocess_latex(latex_code: str) -> str:
    """
    Preprocesses AI-generated LaTeX code to fix common issues.
    
    CALLED BY: main.py before PDF compilation
    
    RECEIVES FROM main.py:
        - latex_code: Raw LaTeX code from AI model
    
    RETURNS TO main.py:
        - cleaned_latex: Preprocessed LaTeX code ready for compilation
    
    RAISES:
        - ValueError: If LaTeX code is invalid or cannot be preprocessed
    """
    if not latex_code or not latex_code.strip():
        raise ValueError("LaTeX code cannot be empty")
    
    # Start with the original code
    cleaned_code = latex_code
    
    # Apply preprocessing steps in order
    cleaned_code = _remove_markdown_blocks(cleaned_code)
    cleaned_code = _remove_explanatory_text(cleaned_code)
    cleaned_code = _fix_document_class(cleaned_code)  # Fix document class issues first
    cleaned_code = _fix_unicode_characters(cleaned_code)
    cleaned_code = _fix_special_characters(cleaned_code)
    cleaned_code = _fix_unescaped_special_chars(cleaned_code)
    cleaned_code = _fix_package_imports(cleaned_code)
    cleaned_code = _fix_malformed_structure(cleaned_code)
    cleaned_code = _fix_itemize_environments(cleaned_code)
    cleaned_code = _fix_textbf_issues(cleaned_code)
    cleaned_code = _fix_line_breaks(cleaned_code)
    cleaned_code = _fix_empty_placeholders(cleaned_code)
    cleaned_code = _validate_structure(cleaned_code)
    
    return cleaned_code


def _remove_markdown_blocks(latex_code: str) -> str:
    """
    Removes markdown code blocks (```) if AI included them despite instructions.
    """
    # Remove opening markdown blocks
    latex_code = re.sub(r'^```latex\s*\n', '', latex_code, flags=re.MULTILINE)
    latex_code = re.sub(r'^```\s*\n', '', latex_code, flags=re.MULTILINE)
    
    # Remove closing markdown blocks
    latex_code = re.sub(r'\n```\s*$', '', latex_code, flags=re.MULTILINE)
    
    # Only strip leading/trailing whitespace, preserve internal indentation
    return latex_code.strip()


def _remove_explanatory_text(latex_code: str) -> str:
    """
    Removes any explanatory text before or after the LaTeX code.
    Ensures code starts with \\documentclass and ends with \\end{document}.
    """
    # Find the start of LaTeX code
    docclass_match = re.search(r'\\documentclass', latex_code)
    if docclass_match:
        latex_code = latex_code[docclass_match.start():]
    
    # Find the end of LaTeX code
    enddoc_match = re.search(r'\\end\{document\}', latex_code)
    if enddoc_match:
        latex_code = latex_code[:enddoc_match.end()]
    
    # Only strip leading/trailing whitespace, preserve internal indentation
    return latex_code.strip()


def _fix_document_class(latex_code: str) -> str:
    """
    Fixes document class issues that cause \normalsize and other font commands to be undefined.
    This is critical for LaTeX compilation success.
    """
    # Check if documentclass exists and is properly formatted
    docclass_match = re.search(r'\\documentclass(?:\[[^\]]*\])?\{[^}]+\}', latex_code)
    
    if not docclass_match:
        # No documentclass found - add a default one
        # Try to determine the best default based on content
        if 'multicol' in latex_code or '\\columnbreak' in latex_code:
            # Two-column template
            default_class = '\\documentclass[11pt,a4paper]{article}'
        elif 'scrartcl' in latex_code or 'KOMA' in latex_code:
            # KOMA-Script template
            default_class = '\\documentclass[paper=a4,fontsize=11pt]{scrartcl}'
        else:
            # Standard article template
            default_class = '\\documentclass[11pt,a4paper]{article}'
        
        # Insert at the beginning
        latex_code = default_class + '\n' + latex_code
        print(f"Warning: Added missing document class: {default_class}")
    
    else:
        # Document class exists, but check if it's malformed
        docclass_line = docclass_match.group(0)
        
        # Check for common issues
        if not re.match(r'\\documentclass(?:\[[^\]]*\])?\{[^}]+\}', docclass_line):
            # Malformed document class - try to fix it
            if '{' in docclass_line and '}' in docclass_line:
                # Has braces, might be fixable
                pass
            else:
                # Completely malformed - replace with default
                latex_code = latex_code.replace(docclass_line, '\\documentclass[11pt,a4paper]{article}')
                print(f"Warning: Fixed malformed document class: {docclass_line}")
    
    return latex_code


def _fix_unicode_characters(latex_code: str) -> str:
    """
    Converts Unicode characters to LaTeX equivalents or ASCII.
    This handles characters that shouldn't be in the output per our system prompt.
    """
    # Arrows
    latex_code = latex_code.replace('→', '->')
    latex_code = latex_code.replace('←', '<-')
    latex_code = latex_code.replace('↑', '^')
    latex_code = latex_code.replace('↓', 'v')
    latex_code = latex_code.replace('⇒', '=>')
    latex_code = latex_code.replace('⇐', '<=')
    latex_code = latex_code.replace('⇝', '->')
    latex_code = latex_code.replace('⟶', '->')
    latex_code = latex_code.replace('⟵', '<-')
    
    # Mathematical symbols
    latex_code = latex_code.replace('≠', '!=')
    latex_code = latex_code.replace('≤', '<=')
    latex_code = latex_code.replace('≥', '>=')
    latex_code = latex_code.replace('±', '+/-')
    latex_code = latex_code.replace('∞', 'infinity')
    latex_code = latex_code.replace('√', 'sqrt')
    
    # Currency symbols (keep dollar sign for now, will handle in escaping)
    latex_code = latex_code.replace('€', 'EUR')
    latex_code = latex_code.replace('£', 'GBP')
    latex_code = latex_code.replace('¥', 'JPY')
    latex_code = latex_code.replace('₹', 'INR')
    
    # Special punctuation
    latex_code = latex_code.replace('"', '"')  # smart quotes opening
    latex_code = latex_code.replace('"', '"')  # smart quotes closing
    latex_code = latex_code.replace(''', "'")  # smart apostrophe opening
    latex_code = latex_code.replace(''', "'")  # smart apostrophe closing
    latex_code = latex_code.replace('—', '---')  # em dash
    latex_code = latex_code.replace('–', '--')   # en dash
    latex_code = latex_code.replace('…', '...')  # ellipsis
    
    # Bullet symbols (should use \item instead)
    latex_code = latex_code.replace('•', '')
    latex_code = latex_code.replace('◦', '')
    latex_code = latex_code.replace('▪', '')
    latex_code = latex_code.replace('▸', '')
    
    # Special symbols
    latex_code = latex_code.replace('©', r'\textcopyright{}')
    latex_code = latex_code.replace('®', r'\textregistered{}')
    latex_code = latex_code.replace('™', r'\texttrademark{}')
    latex_code = latex_code.replace('°', ' degrees')
    latex_code = latex_code.replace('§', 'section')
    
    return latex_code


def _fix_special_characters(latex_code: str) -> str:
    """
    Additional fixes for special characters that might cause compilation issues.
    """
    # Fix any remaining problematic characters
    # Note: Be careful not to escape characters that are already part of LaTeX commands
    
    return latex_code


def _fix_unescaped_special_chars(latex_code: str) -> str:
    """
    Escapes special LaTeX characters that aren't already escaped.
    This is critical for compilation success.
    """
    # This is complex because we need to avoid escaping characters that are:
    # 1. Already escaped
    # 2. Part of LaTeX commands
    # 3. Inside certain environments
    # 4. At the start of lines (LaTeX comments)
    
    # For now, we'll do basic checks for common unescaped characters
    # A more sophisticated approach would parse the LaTeX structure
    
    # Fix unescaped & (ampersand) - but NOT in LaTeX comments (lines starting with %)
    # Look for & that's not preceded by backslash and not in comment lines
    # This regex matches & that is NOT in a line that starts with % (after optional whitespace)
    lines = latex_code.split('\n')
    for i, line in enumerate(lines):
        # Skip comment lines (lines starting with % after optional whitespace)
        if re.match(r'^\s*%', line):
            continue
        # Escape & in non-comment lines
        lines[i] = re.sub(r'(?<!\\)&(?!amp;)', r'\\&', line)
    latex_code = '\n'.join(lines)
    
    # Fix unescaped % (percent) - but NOT at start of lines (LaTeX comments)
    # Look for % that's not preceded by backslash and not at start of line
    # This regex matches % that is NOT at the beginning of a line (after optional whitespace)
    latex_code = re.sub(r'(?<!\\)(?<!^)(?<!\n)%(?!\s*$)', r'\\%', latex_code, flags=re.MULTILINE)
    
    # Fix unescaped # (hash)
    latex_code = re.sub(r'(?<!\\)#(?![0-9])', r'\\#', latex_code)
    
    return latex_code


def _fix_package_imports(latex_code: str) -> str:
    """
    Ensures required packages are imported.
    Handles different template types (ATS, Modern, Two-column, Anti-CV).
    """
    # Check if documentclass is found
    if r'\documentclass' not in latex_code:
        return latex_code
    
    # Find the position after documentclass
    docclass_match = re.search(r'\\documentclass\[[^\]]*\]\{[^}]+\}', latex_code)
    if not docclass_match:
        docclass_match = re.search(r'\\documentclass\{[^}]+\}', latex_code)
    
    if not docclass_match:
        return latex_code
    
    insert_pos = docclass_match.end()
    
    # Define minimal required packages for basic templates
    # Don't add packages if they're already present or if it's a specialized template
    basic_packages = []
    
    # Check if this is a basic ATS template (without specialized packages)
    has_specialized = any(pkg in latex_code for pkg in [
        'sectsty', 'tikz', 'kpfonts', 'titlesec', 'xcolor', 'multicol'
    ])
    
    if not has_specialized:
        # Only add basic packages if missing
        if r'\usepackage{geometry}' not in latex_code and r'\usepackage[margin=' not in latex_code:
            basic_packages.append('\\usepackage[margin=0.75in]{geometry}')
        if r'\usepackage{enumitem}' not in latex_code:
            basic_packages.append('\\usepackage{enumitem}')
        if r'\usepackage{hyperref}' not in latex_code:
            basic_packages.append('\\usepackage{hyperref}')
    
    # Add missing packages
    if basic_packages:
        packages_text = '\n' + '\n'.join(basic_packages)
        latex_code = latex_code[:insert_pos] + packages_text + latex_code[insert_pos:]
    
    return latex_code


def _fix_malformed_structure(latex_code: str) -> str:
    """
    Fixes malformed LaTeX structure where commands are concatenated without proper line breaks.
    """
    # Fix: \textbf{...} directly followed by \begin{itemize}
    latex_code = re.sub(
        r'(\\textbf\{[^}]+\})(\s*)\\begin\{itemize\}',
        r'\1\\\\\n\\begin{itemize}',
        latex_code
    )
    
    # Fix: \textbf{...} directly followed by another \textbf{...}
    latex_code = re.sub(
        r'(\\textbf\{[^}]+\})(\s*)\\textbf\{',
        r'\1\\\\\n\\textbf{',
        latex_code
    )
    
    # Fix: \textbf{...} directly followed by \vspace
    latex_code = re.sub(
        r'(\\textbf\{[^}]+\})(\s*)\\vspace\{',
        r'\1\\\\\n\\vspace{',
        latex_code
    )
    
    # Fix: \textit{...} directly followed by \begin{itemize}
    latex_code = re.sub(
        r'(\\textit\{[^}]+\})(\s*)\\begin\{itemize\}',
        r'\1\\\\\n\\begin{itemize}',
        latex_code
    )
    
    # Fix: Multiple | separators without proper spacing
    latex_code = re.sub(r'\|\s*\|', r'|', latex_code)
    
    return latex_code


def _fix_itemize_environments(latex_code: str) -> str:
    """
    Ensures itemize environments are properly structured.
    """
    # Ensure proper spacing in itemize options
    latex_code = re.sub(
        r'\\begin\{itemize\}\[([^\]]*)\]',
        r'\\begin{itemize}[\1]',
        latex_code
    )
    
    # Check for orphaned \item commands (outside itemize/enumerate)
    # This is a basic check
    lines = latex_code.split('\n')
    in_list_env = False
    for i, line in enumerate(lines):
        if r'\begin{itemize}' in line or r'\begin{enumerate}' in line:
            in_list_env = True
        elif r'\end{itemize}' in line or r'\end{enumerate}' in line:
            in_list_env = False
        elif r'\item' in line and not in_list_env:
            print(f"Warning: Orphaned \\item command at line {i+1}")
    
    # Check for mismatched itemize environments
    itemize_starts = latex_code.count(r'\begin{itemize}')
    itemize_ends = latex_code.count(r'\end{itemize}')
    
    if itemize_starts != itemize_ends:
        print(f"Warning: Mismatched itemize environments ({itemize_starts} starts, {itemize_ends} ends)")
    
    # Ensure items have content (remove empty items)
    latex_code = re.sub(r'\\item\s*\n\s*\\item', r'\\item', latex_code)
    
    return latex_code


def _fix_textbf_issues(latex_code: str) -> str:
    """
    Fixes common issues with \textbf{} and \textit{} commands.
    """
    # Remove completely empty \textbf{} commands (no space, no content)
    latex_code = re.sub(r'\\textbf\{\s*\}', '', latex_code)
    latex_code = re.sub(r'\\textit\{\s*\}', '', latex_code)
    
    # Fix nested \textbf{\textbf{...}} (common AI error)
    latex_code = re.sub(r'\\textbf\{\\textbf\{([^}]+)\}\}', r'\\textbf{\1}', latex_code)
    latex_code = re.sub(r'\\textit\{\\textit\{([^}]+)\}\}', r'\\textit{\1}', latex_code)
    
    # Ensure proper line breaks after \textbf{} when followed by specific commands
    latex_code = re.sub(
        r'(\\textbf\{[^}]+\})(\s*)(\\begin\{itemize\})',
        r'\1\\\\\n\3',
        latex_code
    )
    
    return latex_code


def _fix_line_breaks(latex_code: str) -> str:
    """
    Fixes line break issues and excessive whitespace.
    """
    # The original regex r'\\\\\s+' was problematic because it matched \\ followed by any whitespace
    # including the whitespace that should be preserved as indentation on the next line
    # We need to be more careful and only normalize trailing whitespace after \\ commands
    
    # Remove excessive blank lines (more than 2 consecutive newlines)
    latex_code = re.sub(r'\n\s*\n\s*\n+', '\n\n', latex_code)
    
    # Fix line breaks before \end{itemize}
    latex_code = re.sub(r'\s+\\end\{itemize\}', r'\n\\end{itemize}', latex_code)
    
    # Fix line breaks after \begin{itemize}
    latex_code = re.sub(r'\\begin\{itemize\}\s+', r'\\begin{itemize}\n    ', latex_code)
    
    return latex_code


def _fix_empty_placeholders(latex_code: str) -> str:
    """
    Removes or fixes lines with empty placeholders that AI didn't fill.
    This handles cases where AI left [PLACEHOLDER] markers unfilled.
    """
    # Remove lines that only contain placeholder markers
    latex_code = re.sub(r'^.*\[PLACEHOLDER[^\]]*\].*$\n?', '', latex_code, flags=re.MULTILINE)
    latex_code = re.sub(r'^.*\[.*?_\d+\].*$\n?', '', latex_code, flags=re.MULTILINE)
    
    # Remove lines with only \textbf{} followed by placeholder
    latex_code = re.sub(r'^\\textbf\{\}\s*\|.*$\n?', '', latex_code, flags=re.MULTILINE)
    
    # Remove empty section entries (education, work experience without content)
    # Pattern: \textbf{} | \textit{} or similar empty structures
    latex_code = re.sub(r'^\\textbf\{\}\s*\|[^\n]*\n?', '', latex_code, flags=re.MULTILINE)
    latex_code = re.sub(r'^\\textit\{\}\s*\|[^\n]*\n?', '', latex_code, flags=re.MULTILINE)
    
    # Remove itemize environments with no items
    latex_code = re.sub(
        r'\\begin\{itemize\}[^\n]*\n\s*\\end\{itemize\}',
        '',
        latex_code
    )
    
    return latex_code


def _validate_structure(latex_code: str) -> str:
    """
    Validates basic LaTeX structure and ensures document is compilable.
    """
    # Ensure document has proper structure
    if r'\documentclass' not in latex_code:
        raise ValueError("LaTeX code must contain \\documentclass")
    
    # Validate document class format
    docclass_match = re.search(r'\\documentclass(?:\[[^\]]*\])?\{[^}]+\}', latex_code)
    if not docclass_match:
        raise ValueError("Malformed \\documentclass declaration")
    
    if r'\begin{document}' not in latex_code:
        raise ValueError("LaTeX code must contain \\begin{document}")
    
    if r'\end{document}' not in latex_code:
        raise ValueError("LaTeX code must contain \\end{document}")
    
    # Ensure document environment is properly closed
    doc_starts = latex_code.count(r'\begin{document}')
    doc_ends = latex_code.count(r'\end{document}')
    
    if doc_starts != doc_ends:
        raise ValueError(f"Mismatched document environments ({doc_starts} starts, {doc_ends} ends)")
    
    if doc_starts > 1:
        raise ValueError("Multiple \\begin{document} declarations found")
    
    # Check for unmatched braces (basic check)
    open_braces = latex_code.count('{')
    close_braces = latex_code.count('}')
    
    if open_braces != close_braces:
        print(f"Warning: Mismatched braces ({open_braces} open, {close_braces} close)")
    
    # Ensure document has some content
    content_match = re.search(r'\\begin\{document\}(.*?)\\end\{document\}', latex_code, re.DOTALL)
    if content_match:
        content = content_match.group(1).strip()
        if len(content) < 50:  # Arbitrary minimum
            print("Warning: Document appears to have very little content")
    
    return latex_code


def get_preprocessing_stats(latex_code: str) -> Dict[str, int]:
    """
    Returns statistics about the LaTeX code for debugging.
    
    CALLED BY: main.py for logging/debugging
    
    RETURNS: Dictionary with various statistics about the LaTeX code
    """
    stats = {
        'total_lines': len(latex_code.split('\n')),
        'total_chars': len(latex_code),
        'textbf_commands': len(re.findall(r'\\textbf\{[^}]*\}', latex_code)),
        'textit_commands': len(re.findall(r'\\textit\{[^}]*\}', latex_code)),
        'itemize_environments': latex_code.count(r'\begin{itemize}'),
        'enumerate_environments': latex_code.count(r'\begin{enumerate}'),
        'item_commands': latex_code.count(r'\item'),
        'sections': len(re.findall(r'\\section\{[^}]*\}', latex_code)),
        'subsections': len(re.findall(r'\\subsection\{[^}]*\}', latex_code)),
        'unicode_chars': len(re.findall(r'[^\x00-\x7F]', latex_code)),
        'empty_textbf': len(re.findall(r'\\textbf\{\s*\}', latex_code)),
        'placeholders_remaining': len(re.findall(r'\[.*?\]', latex_code)),
        'hyperlinks': len(re.findall(r'\\href\{', latex_code)),
        'line_breaks': latex_code.count(r'\\\\'),
    }
    
    # Add environment balance checks
    stats['itemize_balanced'] = latex_code.count(r'\begin{itemize}') == latex_code.count(r'\end{itemize}')
    stats['document_balanced'] = latex_code.count(r'\begin{document}') == latex_code.count(r'\end{document}')
    stats['brace_balanced'] = latex_code.count('{') == latex_code.count('}')
    
    return stats


def validate_and_report(latex_code: str) -> tuple[bool, List[str]]:
    """
    Validates LaTeX code and returns validation status with detailed error messages.
    
    CALLED BY: main.py for pre-compilation validation
    
    RETURNS: 
        - is_valid: bool - Whether the LaTeX code passes validation
        - errors: List[str] - List of error messages (empty if valid)
    """
    errors = []
    
    # Check for required structure
    if r'\documentclass' not in latex_code:
        errors.append("Missing \\documentclass declaration")
    
    if r'\begin{document}' not in latex_code:
        errors.append("Missing \\begin{document}")
    
    if r'\end{document}' not in latex_code:
        errors.append("Missing \\end{document}")
    
    # Check for balance
    if latex_code.count(r'\begin{itemize}') != latex_code.count(r'\end{itemize}'):
        errors.append(f"Unbalanced itemize environments: {latex_code.count(r'\begin{itemize}')} begins, {latex_code.count(r'\end{itemize}')} ends")
    
    if latex_code.count(r'\begin{document}') != latex_code.count(r'\end{document}'):
        errors.append(f"Unbalanced document environments: {latex_code.count(r'\begin{document}')} begins, {latex_code.count(r'\end{document}')} ends")
    
    # Check for Unicode characters (should be none after preprocessing)
    unicode_chars = re.findall(r'[^\x00-\x7F]', latex_code)
    if unicode_chars:
        unique_unicode = set(unicode_chars)
        errors.append(f"Found {len(unicode_chars)} Unicode characters: {', '.join(repr(c) for c in list(unique_unicode)[:5])}")
    
    # Check for common problematic patterns
    if re.search(r'\\textbf\{[^}]+\}\\begin\{itemize\}', latex_code):
        errors.append("Found \\textbf directly concatenated with \\begin{itemize} (missing line break)")
    
    # Check for unescaped special characters (basic check)
    # This is tricky as some might be intentional
    unescaped_amp = re.findall(r'(?<!\\)&(?!amp;)(?![^\n]*\\\\)', latex_code)
    if unescaped_amp:
        errors.append(f"Found {len(unescaped_amp)} potentially unescaped & characters")
    
    is_valid = len(errors) == 0
    return is_valid, errors